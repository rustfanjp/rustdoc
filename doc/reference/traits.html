<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Traits</title>

    
    
  <script type="text/javascript" src="../share/jquery-2.1.0.min.js"></script>
  <link rel="stylesheet" type="text/css" href="../share/rust.css">



</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
  <div id="nav">
    <button id="toggle-nav">
    <span class="sr-only">Toggle navigation</span>
    <span class="bar"></span>
    <span class="bar"></span>
    <span class="bar"></span>
  </button>
</div>

<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='notation.html'><b>2.</b> Notation</a>
<ul class='section'>
<li><a  href='unicode-productions.html'><b>2.1.</b> Unicode productions</a>
</li>
<li><a  href='string-table-productions.html'><b>2.2.</b> String table productions</a>
</li>
</ul>
</li>
<li><a  href='lexical-structure.html'><b>3.</b> Lexical structure</a>
<ul class='section'>
<li><a  href='input-format.html'><b>3.1.</b> Input format</a>
</li>
<li><a  href='identifiers.html'><b>3.2.</b> Identifiers</a>
</li>
<li><a  href='comments.html'><b>3.3.</b> Comments</a>
</li>
<li><a  href='whitespace.html'><b>3.4.</b> Whitespace</a>
</li>
<li><a  href='tokens.html'><b>3.5.</b> Tokens</a>
<ul class='section'>
<li><a  href='literals.html'><b>3.5.1.</b> Literals</a>
<ul class='section'>
<li><a  href='examples.html'><b>3.5.1.1.</b> Examples</a>
<ul class='section'>
<li><a  href='characters-and-strings.html'><b>3.5.1.1.1.</b> Characters and strings</a>
</li>
<li><a  href='byte-escapes.html'><b>3.5.1.1.2.</b> Byte escapes</a>
</li>
<li><a  href='unicode-escapes.html'><b>3.5.1.1.3.</b> Unicode escapes</a>
</li>
<li><a  href='numbers.html'><b>3.5.1.1.4.</b> Numbers</a>
</li>
<li><a  href='suffixes.html'><b>3.5.1.1.5.</b> Suffixes</a>
</li>
</ul>
</li>
<li><a  href='character-and-string-literals.html'><b>3.5.1.2.</b> Character and string literals</a>
<ul class='section'>
<li><a  href='character-literals.html'><b>3.5.1.2.1.</b> Character literals</a>
</li>
<li><a  href='string-literals.html'><b>3.5.1.2.2.</b> String literals</a>
</li>
<li><a  href='character-escapes.html'><b>3.5.1.2.3.</b> Character escapes</a>
</li>
<li><a  href='raw-string-literals.html'><b>3.5.1.2.4.</b> Raw string literals</a>
</li>
</ul>
</li>
<li><a  href='byte-and-byte-string-literals.html'><b>3.5.1.3.</b> Byte and byte string literals</a>
<ul class='section'>
<li><a  href='byte-literals.html'><b>3.5.1.3.1.</b> Byte literals</a>
</li>
<li><a  href='byte-string-literals.html'><b>3.5.1.3.2.</b> Byte string literals</a>
</li>
<li><a  href='raw-byte-string-literals.html'><b>3.5.1.3.3.</b> Raw byte string literals</a>
</li>
</ul>
</li>
<li><a  href='number-literals.html'><b>3.5.1.4.</b> Number literals</a>
<ul class='section'>
<li><a  href='integer-literals.html'><b>3.5.1.4.1.</b> Integer literals</a>
</li>
<li><a  href='floating-point-literals.html'><b>3.5.1.4.2.</b> Floating-point literals</a>
</li>
</ul>
</li>
<li><a  href='boolean-literals.html'><b>3.5.1.5.</b> Boolean literals</a>
</li>
</ul>
</li>
<li><a  href='symbols.html'><b>3.5.2.</b> Symbols</a>
</li>
</ul>
</li>
<li><a  href='paths.html'><b>3.6.</b> Paths</a>
</li>
</ul>
</li>
<li><a  href='syntax-extensions.html'><b>4.</b> Syntax extensions</a>
<ul class='section'>
<li><a  href='macros.html'><b>4.1.</b> Macros</a>
<ul class='section'>
<li><a  href='macro-by-example.html'><b>4.1.1.</b> Macro By Example</a>
</li>
<li><a  href='parsing-limitations.html'><b>4.1.2.</b> Parsing limitations</a>
</li>
</ul>
</li>
</ul>
</li>
<li><a  href='crates-and-source-files.html'><b>5.</b> Crates and source files</a>
</li>
<li><a  href='items-and-attributes.html'><b>6.</b> Items and attributes</a>
<ul class='section'>
<li><a  href='items.html'><b>6.1.</b> Items</a>
<ul class='section'>
<li><a  href='type-parameters.html'><b>6.1.1.</b> Type Parameters</a>
</li>
<li><a  href='modules.html'><b>6.1.2.</b> Modules</a>
<ul class='section'>
<li><a  href='extern-crate-declarations.html'><b>6.1.2.1.</b> Extern crate declarations</a>
</li>
<li><a  href='use-declarations.html'><b>6.1.2.2.</b> Use declarations</a>
</li>
</ul>
</li>
<li><a  href='functions.html'><b>6.1.3.</b> Functions</a>
<ul class='section'>
<li><a  href='generic-functions.html'><b>6.1.3.1.</b> Generic functions</a>
</li>
<li><a  href='unsafety.html'><b>6.1.3.2.</b> Unsafety</a>
<ul class='section'>
<li><a  href='unsafe-functions.html'><b>6.1.3.2.1.</b> Unsafe functions</a>
</li>
<li><a  href='unsafe-blocks.html'><b>6.1.3.2.2.</b> Unsafe blocks</a>
</li>
<li><a  href='behavior-considered-undefined.html'><b>6.1.3.2.3.</b> Behavior considered undefined</a>
</li>
<li><a  href='behavior-not-considered-unsafe.html'><b>6.1.3.2.4.</b> Behavior not considered unsafe</a>
</li>
</ul>
</li>
<li><a  href='diverging-functions.html'><b>6.1.3.3.</b> Diverging functions</a>
</li>
<li><a  href='extern-functions.html'><b>6.1.3.4.</b> Extern functions</a>
</li>
</ul>
</li>
<li><a  href='type-aliases.html'><b>6.1.4.</b> Type aliases</a>
</li>
<li><a  href='structures.html'><b>6.1.5.</b> Structures</a>
</li>
<li><a  href='enumerations.html'><b>6.1.6.</b> Enumerations</a>
</li>
<li><a  href='constant-items.html'><b>6.1.7.</b> Constant items</a>
</li>
<li><a  href='static-items.html'><b>6.1.8.</b> Static items</a>
<ul class='section'>
<li><a  href='mutable-statics.html'><b>6.1.8.1.</b> Mutable statics</a>
</li>
</ul>
</li>
<li><a class='active' href='traits.html'><b>6.1.9.</b> Traits</a>
</li>
<li><a  href='implementations.html'><b>6.1.10.</b> Implementations</a>
</li>
<li><a  href='external-blocks.html'><b>6.1.11.</b> External blocks</a>
</li>
</ul>
</li>
<li><a  href='visibility-and-privacy.html'><b>6.2.</b> Visibility and Privacy</a>
<ul class='section'>
<li><a  href='re-exporting-and-visibility.html'><b>6.2.1.</b> Re-exporting and Visibility</a>
</li>
</ul>
</li>
<li><a  href='attributes.html'><b>6.3.</b> Attributes</a>
<ul class='section'>
<li><a  href='crate-only-attributes.html'><b>6.3.1.</b> Crate-only attributes</a>
</li>
<li><a  href='module-only-attributes.html'><b>6.3.2.</b> Module-only attributes</a>
</li>
<li><a  href='function-only-attributes.html'><b>6.3.3.</b> Function-only attributes</a>
</li>
<li><a  href='static-only-attributes.html'><b>6.3.4.</b> Static-only attributes</a>
</li>
<li><a  href='ffi-attributes.html'><b>6.3.5.</b> FFI attributes</a>
</li>
<li><a  href='macro-related-attributes.html'><b>6.3.6.</b> Macro-related attributes</a>
</li>
<li><a  href='miscellaneous-attributes.html'><b>6.3.7.</b> Miscellaneous attributes</a>
</li>
<li><a  href='conditional-compilation.html'><b>6.3.8.</b> Conditional compilation</a>
</li>
<li><a  href='lint-check-attributes.html'><b>6.3.9.</b> Lint check attributes</a>
</li>
<li><a  href='language-items.html'><b>6.3.10.</b> Language items</a>
</li>
<li><a  href='inline-attributes.html'><b>6.3.11.</b> Inline attributes</a>
</li>
<li><a  href='derive.html'><b>6.3.12.</b> `derive`</a>
</li>
<li><a  href='compiler-features.html'><b>6.3.13.</b> Compiler Features</a>
</li>
</ul>
</li>
</ul>
</li>
<li><a  href='statements-and-expressions.html'><b>7.</b> Statements and expressions</a>
<ul class='section'>
<li><a  href='statements.html'><b>7.1.</b> Statements</a>
<ul class='section'>
<li><a  href='declaration-statements.html'><b>7.1.1.</b> Declaration statements</a>
<ul class='section'>
<li><a  href='item-declarations.html'><b>7.1.1.1.</b> Item declarations</a>
</li>
<li><a  href='variable-declarations.html'><b>7.1.1.2.</b> Variable declarations</a>
</li>
</ul>
</li>
<li><a  href='expression-statements.html'><b>7.1.2.</b> Expression statements</a>
</li>
</ul>
</li>
<li><a  href='expressions.html'><b>7.2.</b> Expressions</a>
<ul class='section'>
<li><a  href='lvalues-rvalues-and-temporaries.html'><b>7.2.1.</b> Lvalues, rvalues and temporaries</a>
</li>
<li><a  href='temporary-lifetimes.html'><b>7.2.2.</b> Temporary lifetimes</a>
</li>
<li><a  href='moved-and-copied-types.html'><b>7.2.3.</b> Moved and copied types</a>
</li>
<li><a  href='literal-expressions.html'><b>7.2.4.</b> Literal expressions</a>
</li>
<li><a  href='path-expressions.html'><b>7.2.5.</b> Path expressions</a>
</li>
<li><a  href='tuple-expressions.html'><b>7.2.6.</b> Tuple expressions</a>
</li>
<li><a  href='structure-expressions.html'><b>7.2.7.</b> Structure expressions</a>
</li>
<li><a  href='block-expressions.html'><b>7.2.8.</b> Block expressions</a>
</li>
<li><a  href='method-call-expressions.html'><b>7.2.9.</b> Method-call expressions</a>
</li>
<li><a  href='field-expressions.html'><b>7.2.10.</b> Field expressions</a>
</li>
<li><a  href='array-expressions.html'><b>7.2.11.</b> Array expressions</a>
</li>
<li><a  href='index-expressions.html'><b>7.2.12.</b> Index expressions</a>
</li>
<li><a  href='range-expressions.html'><b>7.2.13.</b> Range expressions</a>
</li>
<li><a  href='unary-operator-expressions.html'><b>7.2.14.</b> Unary operator expressions</a>
</li>
<li><a  href='binary-operator-expressions.html'><b>7.2.15.</b> Binary operator expressions</a>
<ul class='section'>
<li><a  href='arithmetic-operators.html'><b>7.2.15.1.</b> Arithmetic operators</a>
</li>
<li><a  href='bitwise-operators.html'><b>7.2.15.2.</b> Bitwise operators</a>
</li>
<li><a  href='lazy-boolean-operators.html'><b>7.2.15.3.</b> Lazy boolean operators</a>
</li>
<li><a  href='comparison-operators.html'><b>7.2.15.4.</b> Comparison operators</a>
</li>
<li><a  href='type-cast-expressions.html'><b>7.2.15.5.</b> Type cast expressions</a>
</li>
<li><a  href='assignment-expressions.html'><b>7.2.15.6.</b> Assignment expressions</a>
</li>
<li><a  href='compound-assignment-expressions.html'><b>7.2.15.7.</b> Compound assignment expressions</a>
</li>
<li><a  href='operator-precedence.html'><b>7.2.15.8.</b> Operator precedence</a>
</li>
</ul>
</li>
<li><a  href='grouped-expressions.html'><b>7.2.16.</b> Grouped expressions</a>
</li>
<li><a  href='call-expressions.html'><b>7.2.17.</b> Call expressions</a>
</li>
<li><a  href='lambda-expressions.html'><b>7.2.18.</b> Lambda expressions</a>
</li>
<li><a  href='infinite-loops.html'><b>7.2.19.</b> Infinite loops</a>
</li>
<li><a  href='break-expressions.html'><b>7.2.20.</b> Break expressions</a>
</li>
<li><a  href='continue-expressions.html'><b>7.2.21.</b> Continue expressions</a>
</li>
<li><a  href='while-loops.html'><b>7.2.22.</b> While loops</a>
</li>
<li><a  href='for-expressions.html'><b>7.2.23.</b> For expressions</a>
</li>
<li><a  href='if-expressions.html'><b>7.2.24.</b> If expressions</a>
</li>
<li><a  href='match-expressions.html'><b>7.2.25.</b> Match expressions</a>
</li>
<li><a  href='if-let-expressions.html'><b>7.2.26.</b> If let expressions</a>
</li>
<li><a  href='while-let-loops.html'><b>7.2.27.</b> While let loops</a>
</li>
<li><a  href='return-expressions.html'><b>7.2.28.</b> Return expressions</a>
</li>
</ul>
</li>
</ul>
</li>
<li><a  href='type-system.html'><b>8.</b> Type system</a>
<ul class='section'>
<li><a  href='types.html'><b>8.1.</b> Types</a>
<ul class='section'>
<li><a  href='primitive-types.html'><b>8.1.1.</b> Primitive types</a>
<ul class='section'>
<li><a  href='machine-types.html'><b>8.1.1.1.</b> Machine types</a>
</li>
<li><a  href='machine-dependent-integer-types.html'><b>8.1.1.2.</b> Machine-dependent integer types</a>
</li>
</ul>
</li>
<li><a  href='textual-types.html'><b>8.1.2.</b> Textual types</a>
</li>
<li><a  href='tuple-types.html'><b>8.1.3.</b> Tuple types</a>
</li>
<li><a  href='array-and-slice-types.html'><b>8.1.4.</b> Array, and Slice types</a>
</li>
<li><a  href='structure-types.html'><b>8.1.5.</b> Structure types</a>
</li>
<li><a  href='enumerated-types.html'><b>8.1.6.</b> Enumerated types</a>
</li>
<li><a  href='recursive-types.html'><b>8.1.7.</b> Recursive types</a>
</li>
<li><a  href='pointer-types.html'><b>8.1.8.</b> Pointer types</a>
</li>
<li><a  href='function-types.html'><b>8.1.9.</b> Function types</a>
<ul class='section'>
<li><a  href='function-types-for-specific-items.html'><b>8.1.9.1.</b> Function types for specific items</a>
</li>
</ul>
</li>
<li><a  href='closure-types.html'><b>8.1.10.</b> Closure types</a>
</li>
<li><a  href='trait-objects.html'><b>8.1.11.</b> Trait objects</a>
</li>
<li><a  href='type-parameters.html'><b>8.1.12.</b> Type parameters</a>
</li>
<li><a  href='self-types.html'><b>8.1.13.</b> Self types</a>
</li>
</ul>
</li>
<li><a  href='subtyping.html'><b>8.2.</b> Subtyping</a>
</li>
<li><a  href='type-coercions.html'><b>8.3.</b> Type coercions</a>
<ul class='section'>
<li><a  href='coercion-sites.html'><b>8.3.1.</b> Coercion sites</a>
</li>
<li><a  href='coercion-types.html'><b>8.3.2.</b> Coercion types</a>
</li>
</ul>
</li>
</ul>
</li>
<li><a  href='special-traits.html'><b>9.</b> Special traits</a>
<ul class='section'>
<li><a  href='the-copy-trait.html'><b>9.1.</b> The `Copy` trait</a>
</li>
<li><a  href='the-sized-trait.html'><b>9.2.</b> The `Sized` trait</a>
</li>
<li><a  href='the-drop-trait.html'><b>9.3.</b> The `Drop` trait</a>
</li>
<li><a  href='the-deref-trait.html'><b>9.4.</b> The `Deref` trait</a>
</li>
</ul>
</li>
<li><a  href='memory-model.html'><b>10.</b> Memory model</a>
<ul class='section'>
<li><a  href='memory-allocation-and-lifetime.html'><b>10.1.</b> Memory allocation and lifetime</a>
</li>
<li><a  href='memory-ownership.html'><b>10.2.</b> Memory ownership</a>
</li>
<li><a  href='variables.html'><b>10.3.</b> Variables</a>
</li>
</ul>
</li>
<li><a  href='linkage.html'><b>11.</b> Linkage</a>
</li>
<li><a  href='appendix-rationales-and-design-trade-offs.html'><b>12.</b> Appendix: Rationales and design trade-offs</a>
</li>
<li><a  href='appendix-influences.html'><b>13.</b> Appendix: Influences</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Traits</h1>
    
<h3 id="traits" class='section-header'><a
                           href="#traits">Traits</a></h3>
<p>_トレイト(trait) は、型(type)の抽象インターフェイスを記述します。
このインターフェイスは、3種類の付随するアイテム(item)を持ちます。</p>

<ul>
<li>関数(function)</li>
<li>定数(constant)</li>
<li>型</li>
</ul>

<p>最初の仮引数が<code>self</code>という名前である付随関数は、メソッドとも呼ばれ、<code>x.foo()</code>の様に<code>.</code>を使った呼び出し規則を持ちます。</p>

<p>全てのトレイトは、暗黙に型パラメタ(type parameter)<code>Self</code>を定義します。
<code>Self</code>はこのインターフェイスを実装している型を指します。
トレイトは追加で、型仮引数を持つ事も出来ます。
これらの型仮引数は、ほかのトレイトによって制限が付くかもしれません。</p>

<p><code>Self</code>に束縛されているトレイトは、&quot;親トレイト(supertrait)&quot;と見なされる。
トレイトによる束縛は循環しては成らない。
親トレイトは、トレイトが<a href="trait-objects.html">トレイトオブジェクト(trait object)</a>として使われた時に、vtableに存在するメソッドに影響を与える点で、ほかの制約とは異なります。</p>

<p>トレイトは、<a href="implementations.html">実装(implementation)</a>を通して、実装されます。</p>

<p>次のトレイトを考えます。</p>
<span class='rusttest'>fn main() {
    type Surface = i32;
    type BoundingBox = i32;
    trait Shape {
        fn draw(&amp;self, Surface);
        fn bounding_box(&amp;self) -&gt; BoundingBox;
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Shape</span> {
    <span class='kw'>fn</span> <span class='ident'>draw</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>Surface</span>);
    <span class='kw'>fn</span> <span class='ident'>bounding_box</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>BoundingBox</span>;
}</pre>

<p>このトレイトは2つのメソッドを定義します。
このスコープ内で、このトレイトにたいする実装を持つ全ての値は、<code>draw</code>と<code>bounding_box</code>メソッドを持ちます。
メソッドは、<a href="method-call-expressions.html">メソッド呼び出し式</a>によって呼び出せます。</p>

<p>トレイトはデフォルトの実装を記述する事も出来ます。</p>
<span class='rusttest'>fn main() {
    trait Foo {
        fn bar(&amp;self);
        fn baz(&amp;self) { println!(&quot;We called baz.&quot;); }
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>bar</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>);
    <span class='kw'>fn</span> <span class='ident'>baz</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;We called baz.&quot;</span>); }
}</pre>

<p>ここで、<code>baz</code>メソッドはデフォルトの実装を持っています。
従って、それぞれの型は<code>bar</code>だけを実装すれば良いです。
デフォルトの実装をオーバーライドする事も出来ます。</p>

<p>型仮引数を指定する事で、トレイトをジェネリック(generic)にする事もできます。
型仮引数はトレイト名の後の指定され、<a href="generic-functions.html">ジェネリック関数(generic function)</a>と同様な文法が用いられます。</p>
<span class='rusttest'>fn main() {
    trait Seq&lt;T&gt; {
       fn len(&amp;self) -&gt; u32;
       fn elt_at(&amp;self, n: u32) -&gt; T;
       fn iter&lt;F&gt;(&amp;self, F) where F: Fn(T);
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Seq</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
   <span class='kw'>fn</span> <span class='ident'>len</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>u32</span>;
   <span class='kw'>fn</span> <span class='ident'>elt_at</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>n</span>: <span class='ident'>u32</span>) <span class='op'>-&gt;</span> <span class='ident'>T</span>;
   <span class='kw'>fn</span> <span class='ident'>iter</span><span class='op'>&lt;</span><span class='ident'>F</span><span class='op'>&gt;</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>F</span>) <span class='kw'>where</span> <span class='ident'>F</span>: <span class='ident'>Fn</span>(<span class='ident'>T</span>);
}</pre>

<p>トレイトに付随型を定義する事もできます。
例えば、次の<code>Container</code>トレイトを考えてみます。</p>
<span class='rusttest'>fn main() {
    trait Container {
        type E;
        fn empty() -&gt; Self;
        fn insert(&amp;mut self, Self::E);
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Container</span> {
    <span class='kw'>type</span> <span class='ident'>E</span>;
    <span class='kw'>fn</span> <span class='ident'>empty</span>() <span class='op'>-&gt;</span> <span class='kw'>Self</span>;
    <span class='kw'>fn</span> <span class='ident'>insert</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>Self</span>::<span class='ident'>E</span>);
}</pre>

<p>型がこのトレイトを実装するにはメソッドだけでなく、<code>E</code>型も指定する必要があります。。
これは、標準ライブラリにおける<code>Vec</code>型の<code>Container</code>の実装です。</p>
<span class='rusttest'>fn main() {
    trait Container {
        type E;
        fn empty() -&gt; Self;
        fn insert(&amp;mut self, Self::E);
    }
    impl&lt;T&gt; Container for Vec&lt;T&gt; {
        type E = T;
        fn empty() -&gt; Vec&lt;T&gt; { Vec::new() }
        fn insert(&amp;mut self, x: T) { self.push(x); }
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Container</span> <span class='kw'>for</span> <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>type</span> <span class='ident'>E</span> <span class='op'>=</span> <span class='ident'>T</span>;
    <span class='kw'>fn</span> <span class='ident'>empty</span>() <span class='op'>-&gt;</span> <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> { <span class='ident'>Vec</span>::<span class='ident'>new</span>() }
    <span class='kw'>fn</span> <span class='ident'>insert</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>x</span>: <span class='ident'>T</span>) { <span class='self'>self</span>.<span class='ident'>push</span>(<span class='ident'>x</span>); }
}</pre>

<p>ジェネリック関数は、トレイトを型仮引数の <em>束縛(bound)</em> にも用います。
これは次の様な2つの効果が有ります。</p>

<ul>
<li>あると例とを実装しているような型だけを仮引数としてインスタンス化します。</li>
<li>ジェネリック関数の中で、トレイトのメソッドは、仮引数型を持つ値について呼び出す事ができます。</li>
</ul>

<p>これが例です。</p>
<span class='rusttest'>fn main() {
    type Surface = i32;
    trait Shape { fn draw(&amp;self, Surface); }
    fn draw_twice&lt;T: Shape&gt;(surface: Surface, sh: T) {
        sh.draw(surface);
        sh.draw(surface);
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>draw_twice</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Shape</span><span class='op'>&gt;</span>(<span class='ident'>surface</span>: <span class='ident'>Surface</span>, <span class='ident'>sh</span>: <span class='ident'>T</span>) {
    <span class='ident'>sh</span>.<span class='ident'>draw</span>(<span class='ident'>surface</span>);
    <span class='ident'>sh</span>.<span class='ident'>draw</span>(<span class='ident'>surface</span>);
}</pre>

<p>トレイトは、さらに、<a href="trait-objects.html">トレイトオブジェクト(trait object)</a>をトレイトと同じ名前で定義できます。
トレイトオブジェクトの値は、ある型のポインターをこのトレイト型にキャストする事で作られます。
例えば、<code>&amp;T</code>は<code>T: Shapre</code>であれば、<code>&amp;Shape</code>にキャストできます。
<code>Box&lt;T&gt;</code>についても同様です。
このキャストは暗黙でも[明示的(explicit)][type-cast-expressions]にも行えます。
これが明示的なキャストの例です。</p>
<span class='rusttest'>fn main() {
    trait Shape { }
    impl Shape for i32 { }
    let mycircle = 0i32;
    let myshape: Box&lt;Shape&gt; = Box::new(mycircle) as Box&lt;Shape&gt;;
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Shape</span> { }
<span class='kw'>impl</span> <span class='ident'>Shape</span> <span class='kw'>for</span> <span class='ident'>i32</span> { }
<span class='kw'>let</span> <span class='ident'>mycircle</span> <span class='op'>=</span> <span class='number'>0i32</span>;
<span class='kw'>let</span> <span class='ident'>myshape</span>: <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Shape</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='ident'>mycircle</span>) <span class='kw'>as</span> <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Shape</span><span class='op'>&gt;</span>;</pre>

<p>この値は、キャストされた値を持つボックス(box)になります。
また、このボックスはどの実装を
トレイト型を持った値は<a href="method-call-expressions.html">メソッド呼び出し</a>を用いる事が出来ます。
これは、トレイトに束縛された型仮引数をインスタンス化します。</p>

<p>トレイトメソッドは静的で、<code>self</code>実引数を持ちません。
つまり、トレイトメソッドは<code>f(x)</code>といった関数呼び出し文法でのみ呼び出せます。
トレイトの静的メソッドを呼び出すには、トレイト名をモジュール名の様にして扱います。</p>
<span class='rusttest'>fn main() {
    trait Num {
        fn from_i32(n: i32) -&gt; Self;
    }
    impl Num for f64 {
        fn from_i32(n: i32) -&gt; f64 { n as f64 }
    }
    let x: f64 = Num::from_i32(42);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Num</span> {
    <span class='kw'>fn</span> <span class='ident'>from_i32</span>(<span class='ident'>n</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='kw'>Self</span>;
}
<span class='kw'>impl</span> <span class='ident'>Num</span> <span class='kw'>for</span> <span class='ident'>f64</span> {
    <span class='kw'>fn</span> <span class='ident'>from_i32</span>(<span class='ident'>n</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> { <span class='ident'>n</span> <span class='kw'>as</span> <span class='ident'>f64</span> }
}
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>f64</span> <span class='op'>=</span> <span class='ident'>Num</span>::<span class='ident'>from_i32</span>(<span class='number'>42</span>);</pre>

<p>トレイトは、他のトレイトから継承(inherit)されることもあります。</p>
<span class='rusttest'>fn main() {
    trait Shape { fn area(&amp;self) -&gt; f64; }
    trait Circle : Shape { fn radius(&amp;self) -&gt; f64; }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Shape</span> { <span class='kw'>fn</span> <span class='ident'>area</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span>; }
<span class='kw'>trait</span> <span class='ident'>Circle</span> : <span class='ident'>Shape</span> { <span class='kw'>fn</span> <span class='ident'>radius</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span>; }</pre>

<p><code>Circle : Shape</code>という文法は、<code>Circle</code>を実装する型は、<code>Shape</code>も実装する必要がある事を表します。
複数の親トレイトは <code>+</code>によって分けられ、<code>trait Circle : Shape + PartialEq {}</code>の様に記述されます。
<code>Circle</code>を実装している型<code>T</code>は、<code>Shape</code>のメソッドも備えています。</p>

<p>型仮引数を持つ関数において、親トレイトのメソッドは、子トレイトに束縛された型仮引数の値で呼び出されるかもしれません。</p>
<span class='rusttest'>fn main() {
    trait Shape { fn area(&amp;self) -&gt; f64; }
    trait Circle : Shape { fn radius(&amp;self) -&gt; f64; }
    fn radius_times_area&lt;T: Circle&gt;(c: T) -&gt; f64 {
        // `c` is both a Circle and a Shape
        c.radius() * c.area()
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>radius_times_area</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Circle</span><span class='op'>&gt;</span>(<span class='ident'>c</span>: <span class='ident'>T</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='comment'>// `c` is both a Circle and a Shape</span>
    <span class='ident'>c</span>.<span class='ident'>radius</span>() <span class='op'>*</span> <span class='ident'>c</span>.<span class='ident'>area</span>()
}</pre>

<p>同様に、親トレイトメソッドは、トレイトオブジェクトで呼び出されるかもしれません。</p>
<span class='rusttest'>fn main() {
    trait Shape { fn area(&amp;self) -&gt; f64; }
    trait Circle : Shape { fn radius(&amp;self) -&gt; f64; }
    impl Shape for i32 { fn area(&amp;self) -&gt; f64 { 0.0 } }
    impl Circle for i32 { fn radius(&amp;self) -&gt; f64 { 0.0 } }
    let mycircle = 0i32;
    let mycircle = Box::new(mycircle) as Box&lt;Circle&gt;;
    let nonsense = mycircle.radius() * mycircle.area();
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>mycircle</span> <span class='op'>=</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='ident'>mycircle</span>) <span class='kw'>as</span> <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Circle</span><span class='op'>&gt;</span>;
<span class='kw'>let</span> <span class='ident'>nonsense</span> <span class='op'>=</span> <span class='ident'>mycircle</span>.<span class='ident'>radius</span>() <span class='op'>*</span> <span class='ident'>mycircle</span>.<span class='ident'>area</span>();</pre>

    <script type="text/javascript">
        window.playgroundUrl = "https://play.rust-lang.org";
    </script>
    <script src='rustbook.js'></script>
<script src='playpen.js'></script>
</div></div>


</body>
</html>