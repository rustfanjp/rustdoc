<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Traits</title>

    
    
  <script type="text/javascript" src="../share/jquery-2.1.0.min.js"></script>
  <link rel="stylesheet" type="text/css" href="../share/rust.css">



</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
  <div id="nav">
    <button id="toggle-nav">
    <span class="sr-only">Toggle navigation</span>
    <span class="bar"></span>
    <span class="bar"></span>
    <span class="bar"></span>
  </button>
</div>

<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='notation.html'><b>2.</b> Notation</a>
<ul class='section'>
<li><a  href='unicode-productions.html'><b>2.1.</b> Unicode productions</a>
</li>
<li><a  href='string-table-productions.html'><b>2.2.</b> String table productions</a>
</li>
</ul>
</li>
<li><a  href='lexical-structure.html'><b>3.</b> Lexical structure</a>
<ul class='section'>
<li><a  href='input-format.html'><b>3.1.</b> Input format</a>
</li>
<li><a  href='identifiers.html'><b>3.2.</b> Identifiers</a>
</li>
<li><a  href='comments.html'><b>3.3.</b> Comments</a>
</li>
<li><a  href='whitespace.html'><b>3.4.</b> Whitespace</a>
</li>
<li><a  href='tokens.html'><b>3.5.</b> Tokens</a>
<ul class='section'>
<li><a  href='literals.html'><b>3.5.1.</b> Literals</a>
<ul class='section'>
<li><a  href='examples.html'><b>3.5.1.1.</b> Examples</a>
<ul class='section'>
<li><a  href='characters-and-strings.html'><b>3.5.1.1.1.</b> Characters and strings</a>
</li>
<li><a  href='byte-escapes.html'><b>3.5.1.1.2.</b> Byte escapes</a>
</li>
<li><a  href='unicode-escapes.html'><b>3.5.1.1.3.</b> Unicode escapes</a>
</li>
<li><a  href='numbers.html'><b>3.5.1.1.4.</b> Numbers</a>
</li>
<li><a  href='suffixes.html'><b>3.5.1.1.5.</b> Suffixes</a>
</li>
</ul>
</li>
<li><a  href='character-and-string-literals.html'><b>3.5.1.2.</b> Character and string literals</a>
<ul class='section'>
<li><a  href='character-literals.html'><b>3.5.1.2.1.</b> Character literals</a>
</li>
<li><a  href='string-literals.html'><b>3.5.1.2.2.</b> String literals</a>
</li>
<li><a  href='character-escapes.html'><b>3.5.1.2.3.</b> Character escapes</a>
</li>
<li><a  href='raw-string-literals.html'><b>3.5.1.2.4.</b> Raw string literals</a>
</li>
</ul>
</li>
<li><a  href='byte-and-byte-string-literals.html'><b>3.5.1.3.</b> Byte and byte string literals</a>
<ul class='section'>
<li><a  href='byte-literals.html'><b>3.5.1.3.1.</b> Byte literals</a>
</li>
<li><a  href='byte-string-literals.html'><b>3.5.1.3.2.</b> Byte string literals</a>
</li>
<li><a  href='raw-byte-string-literals.html'><b>3.5.1.3.3.</b> Raw byte string literals</a>
</li>
</ul>
</li>
<li><a  href='number-literals.html'><b>3.5.1.4.</b> Number literals</a>
<ul class='section'>
<li><a  href='integer-literals.html'><b>3.5.1.4.1.</b> Integer literals</a>
</li>
<li><a  href='floating-point-literals.html'><b>3.5.1.4.2.</b> Floating-point literals</a>
</li>
</ul>
</li>
<li><a  href='boolean-literals.html'><b>3.5.1.5.</b> Boolean literals</a>
</li>
</ul>
</li>
<li><a  href='symbols.html'><b>3.5.2.</b> Symbols</a>
</li>
</ul>
</li>
<li><a  href='paths.html'><b>3.6.</b> Paths</a>
</li>
</ul>
</li>
<li><a  href='syntax-extensions.html'><b>4.</b> Syntax extensions</a>
<ul class='section'>
<li><a  href='macros.html'><b>4.1.</b> Macros</a>
<ul class='section'>
<li><a  href='macro-by-example.html'><b>4.1.1.</b> Macro By Example</a>
</li>
<li><a  href='parsing-limitations.html'><b>4.1.2.</b> Parsing limitations</a>
</li>
</ul>
</li>
</ul>
</li>
<li><a  href='crates-and-source-files.html'><b>5.</b> Crates and source files</a>
</li>
<li><a  href='items-and-attributes.html'><b>6.</b> Items and attributes</a>
<ul class='section'>
<li><a  href='items.html'><b>6.1.</b> Items</a>
<ul class='section'>
<li><a  href='type-parameters.html'><b>6.1.1.</b> Type Parameters</a>
</li>
<li><a  href='modules.html'><b>6.1.2.</b> Modules</a>
<ul class='section'>
<li><a  href='extern-crate-declarations.html'><b>6.1.2.1.</b> Extern crate declarations</a>
</li>
<li><a  href='use-declarations.html'><b>6.1.2.2.</b> Use declarations</a>
</li>
</ul>
</li>
<li><a  href='functions.html'><b>6.1.3.</b> Functions</a>
<ul class='section'>
<li><a  href='generic-functions.html'><b>6.1.3.1.</b> Generic functions</a>
</li>
<li><a  href='unsafety.html'><b>6.1.3.2.</b> Unsafety</a>
<ul class='section'>
<li><a  href='unsafe-functions.html'><b>6.1.3.2.1.</b> Unsafe functions</a>
</li>
<li><a  href='unsafe-blocks.html'><b>6.1.3.2.2.</b> Unsafe blocks</a>
</li>
<li><a  href='behavior-considered-undefined.html'><b>6.1.3.2.3.</b> Behavior considered undefined</a>
</li>
<li><a  href='behavior-not-considered-unsafe.html'><b>6.1.3.2.4.</b> Behavior not considered unsafe</a>
</li>
</ul>
</li>
<li><a  href='diverging-functions.html'><b>6.1.3.3.</b> Diverging functions</a>
</li>
<li><a  href='extern-functions.html'><b>6.1.3.4.</b> Extern functions</a>
</li>
</ul>
</li>
<li><a  href='type-aliases.html'><b>6.1.4.</b> Type aliases</a>
</li>
<li><a  href='structures.html'><b>6.1.5.</b> Structures</a>
</li>
<li><a  href='enumerations.html'><b>6.1.6.</b> Enumerations</a>
</li>
<li><a  href='constant-items.html'><b>6.1.7.</b> Constant items</a>
</li>
<li><a  href='static-items.html'><b>6.1.8.</b> Static items</a>
<ul class='section'>
<li><a  href='mutable-statics.html'><b>6.1.8.1.</b> Mutable statics</a>
</li>
</ul>
</li>
<li><a class='active' href='traits.html'><b>6.1.9.</b> Traits</a>
</li>
<li><a  href='implementations.html'><b>6.1.10.</b> Implementations</a>
</li>
<li><a  href='external-blocks.html'><b>6.1.11.</b> External blocks</a>
</li>
</ul>
</li>
<li><a  href='visibility-and-privacy.html'><b>6.2.</b> Visibility and Privacy</a>
<ul class='section'>
<li><a  href='re-exporting-and-visibility.html'><b>6.2.1.</b> Re-exporting and Visibility</a>
</li>
</ul>
</li>
<li><a  href='attributes.html'><b>6.3.</b> Attributes</a>
<ul class='section'>
<li><a  href='crate-only-attributes.html'><b>6.3.1.</b> Crate-only attributes</a>
</li>
<li><a  href='module-only-attributes.html'><b>6.3.2.</b> Module-only attributes</a>
</li>
<li><a  href='function-only-attributes.html'><b>6.3.3.</b> Function-only attributes</a>
</li>
<li><a  href='static-only-attributes.html'><b>6.3.4.</b> Static-only attributes</a>
</li>
<li><a  href='ffi-attributes.html'><b>6.3.5.</b> FFI attributes</a>
</li>
<li><a  href='macro-related-attributes.html'><b>6.3.6.</b> Macro-related attributes</a>
</li>
<li><a  href='miscellaneous-attributes.html'><b>6.3.7.</b> Miscellaneous attributes</a>
</li>
<li><a  href='conditional-compilation.html'><b>6.3.8.</b> Conditional compilation</a>
</li>
<li><a  href='lint-check-attributes.html'><b>6.3.9.</b> Lint check attributes</a>
</li>
<li><a  href='language-items.html'><b>6.3.10.</b> Language items</a>
</li>
<li><a  href='inline-attributes.html'><b>6.3.11.</b> Inline attributes</a>
</li>
<li><a  href='derive.html'><b>6.3.12.</b> `derive`</a>
</li>
<li><a  href='compiler-features.html'><b>6.3.13.</b> Compiler Features</a>
</li>
</ul>
</li>
</ul>
</li>
<li><a  href='statements-and-expressions.html'><b>7.</b> Statements and expressions</a>
<ul class='section'>
<li><a  href='statements.html'><b>7.1.</b> Statements</a>
<ul class='section'>
<li><a  href='declaration-statements.html'><b>7.1.1.</b> Declaration statements</a>
<ul class='section'>
<li><a  href='item-declarations.html'><b>7.1.1.1.</b> Item declarations</a>
</li>
<li><a  href='variable-declarations.html'><b>7.1.1.2.</b> Variable declarations</a>
</li>
</ul>
</li>
<li><a  href='expression-statements.html'><b>7.1.2.</b> Expression statements</a>
</li>
</ul>
</li>
<li><a  href='expressions.html'><b>7.2.</b> Expressions</a>
<ul class='section'>
<li><a  href='lvalues-rvalues-and-temporaries.html'><b>7.2.1.</b> Lvalues, rvalues and temporaries</a>
</li>
<li><a  href='temporary-lifetimes.html'><b>7.2.2.</b> Temporary lifetimes</a>
</li>
<li><a  href='moved-and-copied-types.html'><b>7.2.3.</b> Moved and copied types</a>
</li>
<li><a  href='literal-expressions.html'><b>7.2.4.</b> Literal expressions</a>
</li>
<li><a  href='path-expressions.html'><b>7.2.5.</b> Path expressions</a>
</li>
<li><a  href='tuple-expressions.html'><b>7.2.6.</b> Tuple expressions</a>
</li>
<li><a  href='structure-expressions.html'><b>7.2.7.</b> Structure expressions</a>
</li>
<li><a  href='block-expressions.html'><b>7.2.8.</b> Block expressions</a>
</li>
<li><a  href='method-call-expressions.html'><b>7.2.9.</b> Method-call expressions</a>
</li>
<li><a  href='field-expressions.html'><b>7.2.10.</b> Field expressions</a>
</li>
<li><a  href='array-expressions.html'><b>7.2.11.</b> Array expressions</a>
</li>
<li><a  href='index-expressions.html'><b>7.2.12.</b> Index expressions</a>
</li>
<li><a  href='range-expressions.html'><b>7.2.13.</b> Range expressions</a>
</li>
<li><a  href='unary-operator-expressions.html'><b>7.2.14.</b> Unary operator expressions</a>
</li>
<li><a  href='binary-operator-expressions.html'><b>7.2.15.</b> Binary operator expressions</a>
<ul class='section'>
<li><a  href='arithmetic-operators.html'><b>7.2.15.1.</b> Arithmetic operators</a>
</li>
<li><a  href='bitwise-operators.html'><b>7.2.15.2.</b> Bitwise operators</a>
</li>
<li><a  href='lazy-boolean-operators.html'><b>7.2.15.3.</b> Lazy boolean operators</a>
</li>
<li><a  href='comparison-operators.html'><b>7.2.15.4.</b> Comparison operators</a>
</li>
<li><a  href='type-cast-expressions.html'><b>7.2.15.5.</b> Type cast expressions</a>
</li>
<li><a  href='assignment-expressions.html'><b>7.2.15.6.</b> Assignment expressions</a>
</li>
<li><a  href='compound-assignment-expressions.html'><b>7.2.15.7.</b> Compound assignment expressions</a>
</li>
<li><a  href='operator-precedence.html'><b>7.2.15.8.</b> Operator precedence</a>
</li>
</ul>
</li>
<li><a  href='grouped-expressions.html'><b>7.2.16.</b> Grouped expressions</a>
</li>
<li><a  href='call-expressions.html'><b>7.2.17.</b> Call expressions</a>
</li>
<li><a  href='lambda-expressions.html'><b>7.2.18.</b> Lambda expressions</a>
</li>
<li><a  href='infinite-loops.html'><b>7.2.19.</b> Infinite loops</a>
</li>
<li><a  href='break-expressions.html'><b>7.2.20.</b> Break expressions</a>
</li>
<li><a  href='continue-expressions.html'><b>7.2.21.</b> Continue expressions</a>
</li>
<li><a  href='while-loops.html'><b>7.2.22.</b> While loops</a>
</li>
<li><a  href='for-expressions.html'><b>7.2.23.</b> For expressions</a>
</li>
<li><a  href='if-expressions.html'><b>7.2.24.</b> If expressions</a>
</li>
<li><a  href='match-expressions.html'><b>7.2.25.</b> Match expressions</a>
</li>
<li><a  href='if-let-expressions.html'><b>7.2.26.</b> If let expressions</a>
</li>
<li><a  href='while-let-loops.html'><b>7.2.27.</b> While let loops</a>
</li>
<li><a  href='return-expressions.html'><b>7.2.28.</b> Return expressions</a>
</li>
</ul>
</li>
</ul>
</li>
<li><a  href='type-system.html'><b>8.</b> Type system</a>
<ul class='section'>
<li><a  href='types.html'><b>8.1.</b> Types</a>
<ul class='section'>
<li><a  href='primitive-types.html'><b>8.1.1.</b> Primitive types</a>
<ul class='section'>
<li><a  href='machine-types.html'><b>8.1.1.1.</b> Machine types</a>
</li>
<li><a  href='machine-dependent-integer-types.html'><b>8.1.1.2.</b> Machine-dependent integer types</a>
</li>
</ul>
</li>
<li><a  href='textual-types.html'><b>8.1.2.</b> Textual types</a>
</li>
<li><a  href='tuple-types.html'><b>8.1.3.</b> Tuple types</a>
</li>
<li><a  href='array-and-slice-types.html'><b>8.1.4.</b> Array, and Slice types</a>
</li>
<li><a  href='structure-types.html'><b>8.1.5.</b> Structure types</a>
</li>
<li><a  href='enumerated-types.html'><b>8.1.6.</b> Enumerated types</a>
</li>
<li><a  href='recursive-types.html'><b>8.1.7.</b> Recursive types</a>
</li>
<li><a  href='pointer-types.html'><b>8.1.8.</b> Pointer types</a>
</li>
<li><a  href='function-types.html'><b>8.1.9.</b> Function types</a>
<ul class='section'>
<li><a  href='function-types-for-specific-items.html'><b>8.1.9.1.</b> Function types for specific items</a>
</li>
</ul>
</li>
<li><a  href='closure-types.html'><b>8.1.10.</b> Closure types</a>
</li>
<li><a  href='trait-objects.html'><b>8.1.11.</b> Trait objects</a>
</li>
<li><a  href='type-parameters.html'><b>8.1.12.</b> Type parameters</a>
</li>
<li><a  href='self-types.html'><b>8.1.13.</b> Self types</a>
</li>
</ul>
</li>
<li><a  href='subtyping.html'><b>8.2.</b> Subtyping</a>
</li>
<li><a  href='type-coercions.html'><b>8.3.</b> Type coercions</a>
<ul class='section'>
<li><a  href='coercion-sites.html'><b>8.3.1.</b> Coercion sites</a>
</li>
<li><a  href='coercion-types.html'><b>8.3.2.</b> Coercion types</a>
</li>
</ul>
</li>
</ul>
</li>
<li><a  href='special-traits.html'><b>9.</b> Special traits</a>
<ul class='section'>
<li><a  href='the-copy-trait.html'><b>9.1.</b> The `Copy` trait</a>
</li>
<li><a  href='the-sized-trait.html'><b>9.2.</b> The `Sized` trait</a>
</li>
<li><a  href='the-drop-trait.html'><b>9.3.</b> The `Drop` trait</a>
</li>
<li><a  href='the-deref-trait.html'><b>9.4.</b> The `Deref` trait</a>
</li>
</ul>
</li>
<li><a  href='memory-model.html'><b>10.</b> Memory model</a>
<ul class='section'>
<li><a  href='memory-allocation-and-lifetime.html'><b>10.1.</b> Memory allocation and lifetime</a>
</li>
<li><a  href='memory-ownership.html'><b>10.2.</b> Memory ownership</a>
</li>
<li><a  href='variables.html'><b>10.3.</b> Variables</a>
</li>
</ul>
</li>
<li><a  href='linkage.html'><b>11.</b> Linkage</a>
</li>
<li><a  href='appendix-rationales-and-design-trade-offs.html'><b>12.</b> Appendix: Rationales and design trade-offs</a>
</li>
<li><a  href='appendix-influences.html'><b>13.</b> Appendix: Influences</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Traits</h1>
    
<h3 id="traits" class='section-header'><a
                           href="#traits">Traits</a></h3>
<p>A <em>trait</em> describes an abstract interface that types can
implement. This interface consists of associated items, which come in
three varieties:</p>

<ul>
<li>functions</li>
<li>constants</li>
<li>types</li>
</ul>

<p>Associated functions whose first parameter is named <code>self</code> are called
methods and may be invoked using <code>.</code> notation (e.g., <code>x.foo()</code>).</p>

<p>All traits define an implicit type parameter <code>Self</code> that refers to
&quot;the type that is implementing this interface&quot;. Traits may also
contain additional type parameters. These type parameters (including
<code>Self</code>) may be constrained by other traits and so forth as usual.</p>

<p>Trait bounds on <code>Self</code> are considered &quot;supertraits&quot;. These are
required to be acyclic.  Supertraits are somewhat different from other
constraints in that they affect what methods are available in the
vtable when the trait is used as a <a href="#trait-objects">trait object</a>.</p>

<p>Traits are implemented for specific types through separate
<a href="#implementations">implementations</a>.</p>

<p>Consider the following trait:</p>
<span class='rusttest'>fn main() {
    type Surface = i32;
    type BoundingBox = i32;
    trait Shape {
        fn draw(&amp;self, Surface);
        fn bounding_box(&amp;self) -&gt; BoundingBox;
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Shape</span> {
    <span class='kw'>fn</span> <span class='ident'>draw</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>Surface</span>);
    <span class='kw'>fn</span> <span class='ident'>bounding_box</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>BoundingBox</span>;
}</pre>

<p>This defines a trait with two methods. All values that have
<a href="#implementations">implementations</a> of this trait in scope can have their
<code>draw</code> and <code>bounding_box</code> methods called, using <code>value.bounding_box()</code>
<a href="#method-call-expressions">syntax</a>.</p>

<p>Traits can include default implementations of methods, as in:</p>
<span class='rusttest'>fn main() {
    trait Foo {
        fn bar(&amp;self);
        fn baz(&amp;self) { println!(&quot;We called baz.&quot;); }
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {
    <span class='kw'>fn</span> <span class='ident'>bar</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>);
    <span class='kw'>fn</span> <span class='ident'>baz</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;We called baz.&quot;</span>); }
}</pre>

<p>Here the <code>baz</code> method has a default implementation, so types that implement
<code>Foo</code> need only implement <code>bar</code>. It is also possible for implementing types
to override a method that has a default implementation.</p>

<p>Type parameters can be specified for a trait to make it generic. These appear
after the trait name, using the same syntax used in <a href="#generic-functions">generic
functions</a>.</p>
<span class='rusttest'>fn main() {
    trait Seq&lt;T&gt; {
       fn len(&amp;self) -&gt; u32;
       fn elt_at(&amp;self, n: u32) -&gt; T;
       fn iter&lt;F&gt;(&amp;self, F) where F: Fn(T);
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Seq</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
   <span class='kw'>fn</span> <span class='ident'>len</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>u32</span>;
   <span class='kw'>fn</span> <span class='ident'>elt_at</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>n</span>: <span class='ident'>u32</span>) <span class='op'>-&gt;</span> <span class='ident'>T</span>;
   <span class='kw'>fn</span> <span class='ident'>iter</span><span class='op'>&lt;</span><span class='ident'>F</span><span class='op'>&gt;</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>F</span>) <span class='kw'>where</span> <span class='ident'>F</span>: <span class='ident'>Fn</span>(<span class='ident'>T</span>);
}</pre>

<p>It is also possible to define associated types for a trait. Consider the
following example of a <code>Container</code> trait. Notice how the type is available
for use in the method signatures:</p>
<span class='rusttest'>fn main() {
    trait Container {
        type E;
        fn empty() -&gt; Self;
        fn insert(&amp;mut self, Self::E);
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Container</span> {
    <span class='kw'>type</span> <span class='ident'>E</span>;
    <span class='kw'>fn</span> <span class='ident'>empty</span>() <span class='op'>-&gt;</span> <span class='kw'>Self</span>;
    <span class='kw'>fn</span> <span class='ident'>insert</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>Self</span>::<span class='ident'>E</span>);
}</pre>

<p>In order for a type to implement this trait, it must not only provide
implementations for every method, but it must specify the type <code>E</code>. Here&#39;s
an implementation of <code>Container</code> for the standard library type <code>Vec</code>:</p>
<span class='rusttest'>fn main() {
    trait Container {
        type E;
        fn empty() -&gt; Self;
        fn insert(&amp;mut self, Self::E);
    }
    impl&lt;T&gt; Container for Vec&lt;T&gt; {
        type E = T;
        fn empty() -&gt; Vec&lt;T&gt; { Vec::new() }
        fn insert(&amp;mut self, x: T) { self.push(x); }
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Container</span> <span class='kw'>for</span> <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>type</span> <span class='ident'>E</span> <span class='op'>=</span> <span class='ident'>T</span>;
    <span class='kw'>fn</span> <span class='ident'>empty</span>() <span class='op'>-&gt;</span> <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> { <span class='ident'>Vec</span>::<span class='ident'>new</span>() }
    <span class='kw'>fn</span> <span class='ident'>insert</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>x</span>: <span class='ident'>T</span>) { <span class='self'>self</span>.<span class='ident'>push</span>(<span class='ident'>x</span>); }
}</pre>

<p>Generic functions may use traits as <em>bounds</em> on their type parameters. This
will have two effects:</p>

<ul>
<li>Only types that have the trait may instantiate the parameter.</li>
<li>Within the generic function, the methods of the trait can be
called on values that have the parameter&#39;s type.</li>
</ul>

<p>For example:</p>
<span class='rusttest'>fn main() {
    type Surface = i32;
    trait Shape { fn draw(&amp;self, Surface); }
    fn draw_twice&lt;T: Shape&gt;(surface: Surface, sh: T) {
        sh.draw(surface);
        sh.draw(surface);
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>draw_twice</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Shape</span><span class='op'>&gt;</span>(<span class='ident'>surface</span>: <span class='ident'>Surface</span>, <span class='ident'>sh</span>: <span class='ident'>T</span>) {
    <span class='ident'>sh</span>.<span class='ident'>draw</span>(<span class='ident'>surface</span>);
    <span class='ident'>sh</span>.<span class='ident'>draw</span>(<span class='ident'>surface</span>);
}</pre>

<p>Traits also define an <a href="#trait-objects">trait object</a> with the same
name as the trait. Values of this type are created by coercing from a
pointer of some specific type to a pointer of trait type. For example,
<code>&amp;T</code> could be coerced to <code>&amp;Shape</code> if <code>T: Shape</code> holds (and similarly
for <code>Box&lt;T&gt;</code>). This coercion can either be implicit or
<a href="#type-cast-expressions">explicit</a>. Here is an example of an explicit
coercion:</p>
<span class='rusttest'>fn main() {
    trait Shape { }
    impl Shape for i32 { }
    let mycircle = 0i32;
    let myshape: Box&lt;Shape&gt; = Box::new(mycircle) as Box&lt;Shape&gt;;
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Shape</span> { }
<span class='kw'>impl</span> <span class='ident'>Shape</span> <span class='kw'>for</span> <span class='ident'>i32</span> { }
<span class='kw'>let</span> <span class='ident'>mycircle</span> <span class='op'>=</span> <span class='number'>0i32</span>;
<span class='kw'>let</span> <span class='ident'>myshape</span>: <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Shape</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='ident'>mycircle</span>) <span class='kw'>as</span> <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Shape</span><span class='op'>&gt;</span>;</pre>

<p>The resulting value is a box containing the value that was cast, along with
information that identifies the methods of the implementation that was used.
Values with a trait type can have <a href="#method-call-expressions">methods called</a> on
them, for any method in the trait, and can be used to instantiate type
parameters that are bounded by the trait.</p>

<p>Trait methods may be static, which means that they lack a <code>self</code> argument.
This means that they can only be called with function call syntax (<code>f(x)</code>) and
not method call syntax (<code>obj.f()</code>). The way to refer to the name of a static
method is to qualify it with the trait name, treating the trait name like a
module. For example:</p>
<span class='rusttest'>fn main() {
    trait Num {
        fn from_i32(n: i32) -&gt; Self;
    }
    impl Num for f64 {
        fn from_i32(n: i32) -&gt; f64 { n as f64 }
    }
    let x: f64 = Num::from_i32(42);
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Num</span> {
    <span class='kw'>fn</span> <span class='ident'>from_i32</span>(<span class='ident'>n</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='kw'>Self</span>;
}
<span class='kw'>impl</span> <span class='ident'>Num</span> <span class='kw'>for</span> <span class='ident'>f64</span> {
    <span class='kw'>fn</span> <span class='ident'>from_i32</span>(<span class='ident'>n</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> { <span class='ident'>n</span> <span class='kw'>as</span> <span class='ident'>f64</span> }
}
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>f64</span> <span class='op'>=</span> <span class='ident'>Num</span>::<span class='ident'>from_i32</span>(<span class='number'>42</span>);</pre>

<p>Traits may inherit from other traits. For example, in</p>
<span class='rusttest'>fn main() {
    trait Shape { fn area(&amp;self) -&gt; f64; }
    trait Circle : Shape { fn radius(&amp;self) -&gt; f64; }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>Shape</span> { <span class='kw'>fn</span> <span class='ident'>area</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span>; }
<span class='kw'>trait</span> <span class='ident'>Circle</span> : <span class='ident'>Shape</span> { <span class='kw'>fn</span> <span class='ident'>radius</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span>; }</pre>

<p>the syntax <code>Circle : Shape</code> means that types that implement <code>Circle</code> must also
have an implementation for <code>Shape</code>. Multiple supertraits are separated by <code>+</code>,
<code>trait Circle : Shape + PartialEq { }</code>. In an implementation of <code>Circle</code> for a
given type <code>T</code>, methods can refer to <code>Shape</code> methods, since the typechecker
checks that any type with an implementation of <code>Circle</code> also has an
implementation of <code>Shape</code>.</p>

<p>In type-parameterized functions, methods of the supertrait may be called on
values of subtrait-bound type parameters. Referring to the previous example of
<code>trait Circle : Shape</code>:</p>
<span class='rusttest'>fn main() {
    trait Shape { fn area(&amp;self) -&gt; f64; }
    trait Circle : Shape { fn radius(&amp;self) -&gt; f64; }
    fn radius_times_area&lt;T: Circle&gt;(c: T) -&gt; f64 {
        // `c` is both a Circle and a Shape
        c.radius() * c.area()
    }
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>radius_times_area</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Circle</span><span class='op'>&gt;</span>(<span class='ident'>c</span>: <span class='ident'>T</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='comment'>// `c` is both a Circle and a Shape</span>
    <span class='ident'>c</span>.<span class='ident'>radius</span>() <span class='op'>*</span> <span class='ident'>c</span>.<span class='ident'>area</span>()
}</pre>

<p>Likewise, supertrait methods may also be called on trait objects.</p>
<span class='rusttest'>fn main() {
    trait Shape { fn area(&amp;self) -&gt; f64; }
    trait Circle : Shape { fn radius(&amp;self) -&gt; f64; }
    impl Shape for i32 { fn area(&amp;self) -&gt; f64 { 0.0 } }
    impl Circle for i32 { fn radius(&amp;self) -&gt; f64 { 0.0 } }
    let mycircle = 0i32;
    let mycircle = Box::new(mycircle) as Box&lt;Circle&gt;;
    let nonsense = mycircle.radius() * mycircle.area();
    
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>mycircle</span> <span class='op'>=</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='ident'>mycircle</span>) <span class='kw'>as</span> <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Circle</span><span class='op'>&gt;</span>;
<span class='kw'>let</span> <span class='ident'>nonsense</span> <span class='op'>=</span> <span class='ident'>mycircle</span>.<span class='ident'>radius</span>() <span class='op'>*</span> <span class='ident'>mycircle</span>.<span class='ident'>area</span>();</pre>

    <script type="text/javascript">
        window.playgroundUrl = "https://play.rust-lang.org";
    </script>
    <script src='rustbook.js'></script>
<script src='playpen.js'></script>
</div></div>


</body>
</html>