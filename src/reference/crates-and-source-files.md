% Crates and source files

# Crates and source files

他の言語と同様に、Rustはインタプリタとして実装する事もできますが、今の所は唯一のコンパイラしか有りません。
ですので、Rustコンパイラについて言及する時は、*the*を付けます。
このセクションでは、コンパイラ実装を想定しています。

Rustの意味論では、コンパイル時と実行時は違うフェーズだと認識されます。[^phase-distinction]
*静的解釈*を持つ意味論は、コンパイルが成功するか失敗するかを決めますが、*動的解釈*を持つ意味論は、プログラムの振舞を実行時に決定します。

[^phase-distinction]: この区別は、インタプリタ実装でも存在し得ます。
    構文解析、型チェック、詳細な検査(lint)を行ってからプログラムを実行するかもしれません。

Rustのコンパイルモデルは、_クレート(crate)_を中心としています。
それぞれのコンパイルでは、1つのソースコードから、1つのクレートを処理し、1つのバイナリを生成します。[^cratesourcefile]


[^cratesourcefile]: クレートは、ECMA-335 CLIモデルにおける*アセンブリ*、 SML/NJコンパイルマネージャにおける*ライブラリ*、フラットモジュールシステムにおける*ユニット*、Mesaにおける*コンフィギュレーション*等の類似物です。

クレートは、コンパイル、リンク、バージョン管理、配布、実行時ロードの基本単位です。
クレートは、ネストした[モジュール(module)][modules]スコープの木を持ちます。
この木のトップレベルは、無名モジュールです。
クレート内の任意のアイテムはこのモジュール木に基づいた[標準パス](paths)を持ちます。

[modules]: modules.html
[paths]: paths.html

Rustコンパイラは、必ず1つのソースコードと共に呼び出されます。
そして、1つのクレートを出力します。
ソースファイルの処理の過程で、他のソースファイルがモジュールとしてロードされる事も有ります。
ソースファイルの拡張子は`.rs`です。

Rustのソースファイルには、このソースファイルの外で定義されたモジュールの名前と今のクレート内での位置を記述する事が出来ます。
そのモジュールは、`mod_item`によってか定義されているか、クレートその物です。
全てのソースファイルは、モジュールですが、全てのモジュールがそれ専用のソースファイルを持っている訳では有りません。
[モジュール定義(module definition)][modules]は、1つのファイルの中でネストできます。

それぞれのソースファイルは、`item`定義を含んでいるかもしれません。
また、それらの定義は、任意の数の[アトリビュート(attribute)][item-and-attributes]を伴っているかもしれません。
それらのアトリビュートはコンパイラの動作に影響を与えます。
クレート直下の無名モジュールは、クレート全体に適応される追加のアトリビュートを持っています。

[modules]: modules.html
[item-and-attributes]: item-and-attributes.html

```rust
// Specify the crate name.
#![crate_name = "projx"]

// Specify the type of output artifact.
#![crate_type = "lib"]

// Turn on a warning.
// This can be done in any module, not just the anonymous crate module.
#![warn(non_camel_case_types)]
```

`main`関数を持っているクレートは実行可能形式にコンパイルできます。
もし、`main`関数が存在するなら、その返値の型は、[`unit`][tuple-types]で、引数を取ってはいけません。
